<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>데이터 과학 민주화</title>
  <meta name="description" content="데이터 과학 민주화">
  <meta name="generator" content="bookdown 0.6.2 and GitBook 2.6.7">

  <meta property="og:title" content="데이터 과학 민주화" />
  <meta property="og:type" content="book" />
  
  
  
  <meta name="github-repo" content="statkclee/r4inf" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="데이터 과학 민주화" />
  
  
  

<meta name="author" content="이광춘 - R Meetup 운영">


<meta name="date" content="2018-02-17">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="r-func.html">
<link rel="next" href="r-string.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">땅, 자본, 데이터</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>기계와의 경쟁</a></li>
<li class="chapter" data-level="1" data-path="r-intro.html"><a href="r-intro.html"><i class="fa fa-check"></i><b>1</b> 왜 프로그래밍을 배워야 하는가?</a><ul>
<li class="chapter" data-level="1.1" data-path="r-intro.html"><a href="r-intro.html#r-intro-motivation"><i class="fa fa-check"></i><b>1.1</b> 창의성과 동기</a></li>
<li class="chapter" data-level="1.2" data-path="r-intro.html"><a href="r-intro.html#r-intro-hardware-architecture"><i class="fa fa-check"></i><b>1.2</b> 컴퓨터 하드웨어 아키텍처</a></li>
<li class="chapter" data-level="1.3" data-path="r-intro.html"><a href="r-intro.html#r-intro-programming"><i class="fa fa-check"></i><b>1.3</b> 프로그래밍 이해하기</a></li>
<li class="chapter" data-level="1.4" data-path="r-intro.html"><a href="r-intro.html#r-intro-word-sentence"><i class="fa fa-check"></i><b>1.4</b> 단어와 문장</a></li>
<li class="chapter" data-level="1.5" data-path="r-intro.html"><a href="r-intro.html#r-intro-conversation"><i class="fa fa-check"></i><b>1.5</b> R과 대화하기</a></li>
<li class="chapter" data-level="1.6" data-path="r-intro.html"><a href="r-intro.html#r-intro-interpreter"><i class="fa fa-check"></i><b>1.6</b> 전문용어: 인터프리터와 컴파일러</a></li>
<li class="chapter" data-level="1.7" data-path="r-intro.html"><a href="r-intro.html#r-intro-write-program"><i class="fa fa-check"></i><b>1.7</b> 프로그램 작성하기</a></li>
<li class="chapter" data-level="1.8" data-path="r-intro.html"><a href="r-intro.html#r-intro-what-is-a-program"><i class="fa fa-check"></i><b>1.8</b> 프로그램이란 무엇인가?</a></li>
<li class="chapter" data-level="1.9" data-path="r-intro.html"><a href="r-intro.html#r-intro-program-component"><i class="fa fa-check"></i><b>1.9</b> 프로그램 구성요소</a></li>
<li class="chapter" data-level="1.10" data-path="r-intro.html"><a href="r-intro.html#r-intro-bug"><i class="fa fa-check"></i><b>1.10</b> 프로그램이 잘못되면?</a></li>
<li class="chapter" data-level="1.11" data-path="r-intro.html"><a href="r-intro.html#r-intro-journey"><i class="fa fa-check"></i><b>1.11</b> 학습으로의 여정</a></li>
<li class="chapter" data-level="1.12" data-path="r-intro.html"><a href="r-intro.html#r-intro-terminology"><i class="fa fa-check"></i><b>1.12</b> 용어사전</a></li>
<li class="chapter" data-level="1.13" data-path="r-intro.html"><a href="r-intro.html#r-intro-exercise"><i class="fa fa-check"></i><b>1.13</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="r-var.html"><a href="r-var.html"><i class="fa fa-check"></i><b>2</b> 변수, 표현식, 문장(Statement)</a><ul>
<li class="chapter" data-level="2.1" data-path="r-var.html"><a href="r-var.html#r-var-value-type"><i class="fa fa-check"></i><b>2.1</b> 값(Value)과 자료형(Type)</a></li>
<li class="chapter" data-level="2.2" data-path="r-var.html"><a href="r-var.html#r-var-variable"><i class="fa fa-check"></i><b>2.2</b> 변수(Variable)</a></li>
<li class="chapter" data-level="2.3" data-path="r-var.html"><a href="r-var.html#r-var-keywords"><i class="fa fa-check"></i><b>2.3</b> 변수명(Variable name)과 예약어(keywords)</a></li>
<li class="chapter" data-level="2.4" data-path="r-var.html"><a href="r-var.html#r-var-statement"><i class="fa fa-check"></i><b>2.4</b> 문장(Statement)</a></li>
<li class="chapter" data-level="2.5" data-path="r-var.html"><a href="r-var.html#r-var-operator"><i class="fa fa-check"></i><b>2.5</b> 연산자(Operator)와 피연산자(Operands)</a></li>
<li class="chapter" data-level="2.6" data-path="r-var.html"><a href="r-var.html#r-var-expression"><i class="fa fa-check"></i><b>2.6</b> 표현식(Expression)</a></li>
<li class="chapter" data-level="2.7" data-path="r-var.html"><a href="r-var.html#r-var-order-operations"><i class="fa fa-check"></i><b>2.7</b> 연산자 적용 우선순위 (Order of Operations)</a></li>
<li class="chapter" data-level="2.8" data-path="r-var.html"><a href="r-var.html#r-var-modular"><i class="fa fa-check"></i><b>2.8</b> 나머지 연산자 (Modulus Operator)</a></li>
<li class="chapter" data-level="2.9" data-path="r-var.html"><a href="r-var.html#r-var-string-operator"><i class="fa fa-check"></i><b>2.9</b> 문자열 연산자 (String Operator)</a></li>
<li class="chapter" data-level="2.10" data-path="r-var.html"><a href="r-var.html#r-var-input"><i class="fa fa-check"></i><b>2.10</b> 사용자에게서 입력값 받기</a></li>
<li class="chapter" data-level="2.11" data-path="r-var.html"><a href="r-var.html#r-var-comment"><i class="fa fa-check"></i><b>2.11</b> 주석</a></li>
<li class="chapter" data-level="2.12" data-path="r-var.html"><a href="r-var.html#r-var-name"><i class="fa fa-check"></i><b>2.12</b> 연상되는 변수명 만들기</a></li>
<li class="chapter" data-level="2.13" data-path="r-var.html"><a href="r-var.html#r-var-debug"><i class="fa fa-check"></i><b>2.13</b> 디버깅(Debugging)</a></li>
<li class="chapter" data-level="2.14" data-path="r-var.html"><a href="r-var.html#r-var-terminology"><i class="fa fa-check"></i><b>2.14</b> 용어 설명</a></li>
<li class="chapter" data-level="2.15" data-path="r-var.html"><a href="r-var.html#r-var-ex"><i class="fa fa-check"></i><b>2.15</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="r-cont.html"><a href="r-cont.html"><i class="fa fa-check"></i><b>3</b> 조건부 실행</a><ul>
<li class="chapter" data-level="3.1" data-path="r-cont.html"><a href="r-cont.html#r-cont-boolean"><i class="fa fa-check"></i><b>3.1</b> 부울 표현식(Boolean expressions)</a></li>
<li class="chapter" data-level="3.2" data-path="r-cont.html"><a href="r-cont.html#r-cont-logical-operator"><i class="fa fa-check"></i><b>3.2</b> 논리 연산자</a></li>
<li class="chapter" data-level="3.3" data-path="r-cont.html"><a href="r-cont.html#r-cont-run"><i class="fa fa-check"></i><b>3.3</b> 조건문 실행</a></li>
<li class="chapter" data-level="3.4" data-path="r-cont.html"><a href="r-cont.html#r-cont-alternative"><i class="fa fa-check"></i><b>3.4</b> 대안 실행</a></li>
<li class="chapter" data-level="3.5" data-path="r-cont.html"><a href="r-cont.html#r-cont-chained"><i class="fa fa-check"></i><b>3.5</b> 연쇄 조건문</a></li>
<li class="chapter" data-level="3.6" data-path="r-cont.html"><a href="r-cont.html#r-cont-nested"><i class="fa fa-check"></i><b>3.6</b> 중첩 조건문</a></li>
<li class="chapter" data-level="3.7" data-path="r-cont.html"><a href="r-cont.html#r-cont-try-catch"><i class="fa fa-check"></i><b>3.7</b> try와 catch를 활용한 예외 처리</a></li>
<li class="chapter" data-level="3.8" data-path="r-cont.html"><a href="r-cont.html#r-cont-short-circuit"><i class="fa fa-check"></i><b>3.8</b> 논리 연산식의 단락(Short circuit) 평가</a></li>
<li class="chapter" data-level="3.9" data-path="r-cont.html"><a href="r-cont.html#r-cont-debugging"><i class="fa fa-check"></i><b>3.9</b> 디버깅(Debugging)</a></li>
<li class="chapter" data-level="3.10" data-path="r-cont.html"><a href="r-cont.html#r-cont-terminology"><i class="fa fa-check"></i><b>3.10</b> 용어 정의</a></li>
<li class="chapter" data-level="3.11" data-path="r-cont.html"><a href="r-cont.html#r-cont-ex"><i class="fa fa-check"></i><b>3.11</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="r-func.html"><a href="r-func.html"><i class="fa fa-check"></i><b>4</b> 함수</a><ul>
<li class="chapter" data-level="4.1" data-path="r-func.html"><a href="r-func.html#r-func-call"><i class="fa fa-check"></i><b>4.1</b> 함수 호출</a></li>
<li class="chapter" data-level="4.2" data-path="r-func.html"><a href="r-func.html#r-func-builtin"><i class="fa fa-check"></i><b>4.2</b> 내장(Built-in) 함수</a></li>
<li class="chapter" data-level="4.3" data-path="r-func.html"><a href="r-func.html#r-func-type"><i class="fa fa-check"></i><b>4.3</b> 자료형(type) 변환 함수</a></li>
<li class="chapter" data-level="4.4" data-path="r-func.html"><a href="r-func.html#r-func-random-number"><i class="fa fa-check"></i><b>4.4</b> 난수(Random numbers)</a></li>
<li class="chapter" data-level="4.5" data-path="r-func.html"><a href="r-func.html#r-func-math"><i class="fa fa-check"></i><b>4.5</b> 수학 함수</a></li>
<li class="chapter" data-level="4.6" data-path="r-func.html"><a href="r-func.html#r-func-new-function"><i class="fa fa-check"></i><b>4.6</b> 신규 함수 추가</a></li>
<li class="chapter" data-level="4.7" data-path="r-func.html"><a href="r-func.html#r-func-how-to-use"><i class="fa fa-check"></i><b>4.7</b> 함수 정의와 사용법</a></li>
<li class="chapter" data-level="4.8" data-path="r-func.html"><a href="r-func.html#r-func-control"><i class="fa fa-check"></i><b>4.8</b> 실행 흐름</a></li>
<li class="chapter" data-level="4.9" data-path="r-func.html"><a href="r-func.html#r-func-parameter-argument"><i class="fa fa-check"></i><b>4.9</b> 매개 변수(parameter)와 인수(argument)</a></li>
<li class="chapter" data-level="4.10" data-path="r-func.html"><a href="r-func.html#r-func-void"><i class="fa fa-check"></i><b>4.10</b> 결과있는 함수(fruitful function)와 빈 함수(void function)</a></li>
<li class="chapter" data-level="4.11" data-path="r-func.html"><a href="r-func.html#r-func-why"><i class="fa fa-check"></i><b>4.11</b> 왜 함수를 사용하는가?</a></li>
<li class="chapter" data-level="4.12" data-path="r-func.html"><a href="r-func.html#r-func-debug"><i class="fa fa-check"></i><b>4.12</b> 디버깅</a></li>
<li class="chapter" data-level="4.13" data-path="r-func.html"><a href="r-func.html#-r-func-terminology"><i class="fa fa-check"></i><b>4.13</b> 용어정의 {r-func-terminology}</a></li>
<li class="chapter" data-level="4.14" data-path="r-func.html"><a href="r-func.html#-r-func-ex"><i class="fa fa-check"></i><b>4.14</b> 연습문제 {r-func-ex}</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="r-iter.html"><a href="r-iter.html"><i class="fa fa-check"></i><b>5</b> 반복(Iteration)</a><ul>
<li class="chapter" data-level="5.1" data-path="r-iter.html"><a href="r-iter.html#r-iter-update"><i class="fa fa-check"></i><b>5.1</b> 변수 갱신</a></li>
<li class="chapter" data-level="5.2" data-path="r-iter.html"><a href="r-iter.html#r-iter-while"><i class="fa fa-check"></i><b>5.2</b> while문</a></li>
<li class="chapter" data-level="5.3" data-path="r-iter.html"><a href="r-iter.html#r-iter-infinite-loop"><i class="fa fa-check"></i><b>5.3</b> 무한 루프</a></li>
<li class="chapter" data-level="5.4" data-path="r-iter.html"><a href="r-iter.html#--break"><i class="fa fa-check"></i><b>5.4</b> 무한 반복과 <code id="r-iter-infinite-loop-break">break</code></a></li>
<li class="chapter" data-level="5.5" data-path="r-iter.html"><a href="r-iter.html#r-iter-stop"><i class="fa fa-check"></i><b>5.5</b> <code>next</code>로 반복 종료</a></li>
<li class="chapter" data-level="5.6" data-path="r-iter.html"><a href="r-iter.html#r-iter-for"><i class="fa fa-check"></i><b>5.6</b> for문을 사용한 명확한 루프</a></li>
<li class="chapter" data-level="5.7" data-path="r-iter.html"><a href="r-iter.html#r-iter-for-pattern"><i class="fa fa-check"></i><b>5.7</b> 루프 패턴</a><ul>
<li class="chapter" data-level="5.7.1" data-path="r-iter.html"><a href="r-iter.html#r-iter-for-pattern-sum"><i class="fa fa-check"></i><b>5.7.1</b> 계수(counting)와 합산 루프</a></li>
<li class="chapter" data-level="5.7.2" data-path="r-iter.html"><a href="r-iter.html#r-iter-for-min-max"><i class="fa fa-check"></i><b>5.7.2</b> 최대값과 최소값 루프</a></li>
</ul></li>
<li class="chapter" data-level="5.8" data-path="r-iter.html"><a href="r-iter.html#r-iter-debug"><i class="fa fa-check"></i><b>5.8</b> 디버깅</a></li>
<li class="chapter" data-level="5.9" data-path="r-iter.html"><a href="r-iter.html#r-iter-terminology"><i class="fa fa-check"></i><b>5.9</b> 용어정의</a></li>
<li class="chapter" data-level="5.10" data-path="r-iter.html"><a href="r-iter.html#r-iter-ex"><i class="fa fa-check"></i><b>5.10</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="r-string.html"><a href="r-string.html"><i class="fa fa-check"></i><b>6</b> 문자열</a><ul>
<li class="chapter" data-level="6.1" data-path="r-string.html"><a href="r-string.html#r-string-sequence"><i class="fa fa-check"></i><b>6.1</b> 문자열은 순열(sequence)이다.</a></li>
<li class="chapter" data-level="6.2" data-path="r-string.html"><a href="r-string.html#r-string-length"><i class="fa fa-check"></i><b>6.2</b> <code>length()</code> 함수 사용 문자열 길이 구하기</a></li>
<li class="chapter" data-level="6.3" data-path="r-string.html"><a href="r-string.html#r-string-traversal"><i class="fa fa-check"></i><b>6.3</b> 루프를 사용한 문자열 운행법</a></li>
<li class="chapter" data-level="6.4" data-path="r-string.html"><a href="r-string.html#r-string-slice"><i class="fa fa-check"></i><b>6.4</b> 문자열 슬라이스(slice)</a></li>
<li class="chapter" data-level="6.5" data-path="r-string.html"><a href="r-string.html#r-string-count"><i class="fa fa-check"></i><b>6.5</b> 루프 돌기(looping) 계수(counting)</a></li>
<li class="chapter" data-level="6.6" data-path="r-string.html"><a href="r-string.html#r-string-in-operator"><i class="fa fa-check"></i><b>6.6</b> <code>%in%</code> 연산자</a></li>
<li class="chapter" data-level="6.7" data-path="r-string.html"><a href="r-string.html#r-string-comparison-operator"><i class="fa fa-check"></i><b>6.7</b> 문자열 비교</a></li>
<li class="chapter" data-level="6.8" data-path="r-string.html"><a href="r-string.html#r-string-method"><i class="fa fa-check"></i><b>6.8</b> 문자열 함수</a></li>
<li class="chapter" data-level="6.9" data-path="r-string.html"><a href="r-string.html#r-string-parsing"><i class="fa fa-check"></i><b>6.9</b> 문자열 파싱(Parsing)</a></li>
<li class="chapter" data-level="6.10" data-path="r-string.html"><a href="r-string.html#r-string-format"><i class="fa fa-check"></i><b>6.10</b> 서식 연산자</a></li>
<li class="chapter" data-level="6.11" data-path="r-string.html"><a href="r-string.html#r-string-debug"><i class="fa fa-check"></i><b>6.11</b> 디버깅</a></li>
<li class="chapter" data-level="6.12" data-path="r-string.html"><a href="r-string.html#r-string-terminology"><i class="fa fa-check"></i><b>6.12</b> 용어정의</a></li>
<li class="chapter" data-level="6.13" data-path="r-string.html"><a href="r-string.html#r-string-ex"><i class="fa fa-check"></i><b>6.13</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="r-file.html"><a href="r-file.html"><i class="fa fa-check"></i><b>7</b> 파일</a><ul>
<li class="chapter" data-level="7.1" data-path="r-file.html"><a href="r-file.html#r-file-persistence"><i class="fa fa-check"></i><b>7.1</b> 영속성(Persistence)</a></li>
<li class="chapter" data-level="7.2" data-path="r-file.html"><a href="r-file.html#r-file-open"><i class="fa fa-check"></i><b>7.2</b> 파일 열기</a></li>
<li class="chapter" data-level="7.3" data-path="r-file.html"><a href="r-file.html#r-file-txt"><i class="fa fa-check"></i><b>7.3</b> 텍스트 파일과 라인</a></li>
<li class="chapter" data-level="7.4" data-path="r-file.html"><a href="r-file.html#r-file-open-handler"><i class="fa fa-check"></i><b>7.4</b> 파일 읽어오기</a></li>
<li class="chapter" data-level="7.5" data-path="r-file.html"><a href="r-file.html#r-file-search"><i class="fa fa-check"></i><b>7.5</b> 파일 검색</a></li>
<li class="chapter" data-level="7.6" data-path="r-file.html"><a href="r-file.html#r-file-user-input"><i class="fa fa-check"></i><b>7.6</b> 사용자가 파일명을 선택하게 만들기</a></li>
<li class="chapter" data-level="7.7" data-path="r-file.html"><a href="r-file.html#r-file-trycatch"><i class="fa fa-check"></i><b>7.7</b> tryCatch 사용하기</a></li>
<li class="chapter" data-level="7.8" data-path="r-file.html"><a href="r-file.html#r-file-write"><i class="fa fa-check"></i><b>7.8</b> 파일에 쓰기</a></li>
<li class="chapter" data-level="7.9" data-path="r-file.html"><a href="r-file.html#r-file-debug"><i class="fa fa-check"></i><b>7.9</b> 디버깅</a></li>
<li class="chapter" data-level="7.10" data-path="r-file.html"><a href="r-file.html#r-file-terminology"><i class="fa fa-check"></i><b>7.10</b> 용어정의</a></li>
<li class="chapter" data-level="7.11" data-path="r-file.html"><a href="r-file.html#r-file-ex"><i class="fa fa-check"></i><b>7.11</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="r-list.html"><a href="r-list.html"><i class="fa fa-check"></i><b>8</b> 리스트 (List)</a><ul>
<li class="chapter" data-level="8.1" data-path="r-list.html"><a href="r-list.html#r-list-sequence"><i class="fa fa-check"></i><b>8.1</b> 리스트는 순서(sequence)다.</a></li>
<li class="chapter" data-level="8.2" data-path="r-list.html"><a href="r-list.html#r-list-mutable"><i class="fa fa-check"></i><b>8.2</b> 리스트는 변경가능하다.</a></li>
<li class="chapter" data-level="8.3" data-path="r-list.html"><a href="r-list.html#r-list-traversal"><i class="fa fa-check"></i><b>8.3</b> 리스트 운행법</a></li>
<li class="chapter" data-level="8.4" data-path="r-list.html"><a href="r-list.html#--r-list-operator"><i class="fa fa-check"></i><b>8.4</b> 리스트 연산자 {r-list-operator}</a></li>
<li class="chapter" data-level="8.5" data-path="r-list.html"><a href="r-list.html#r-list-slice"><i class="fa fa-check"></i><b>8.5</b> 리스트 슬라이스(List slices)</a></li>
<li class="chapter" data-level="8.6" data-path="r-list.html"><a href="r-list.html#r-list-function"><i class="fa fa-check"></i><b>8.6</b> 리스트 함수</a></li>
<li class="chapter" data-level="8.7" data-path="r-list.html"><a href="r-list.html#r-list-delete"><i class="fa fa-check"></i><b>8.7</b> 리스트 요소 삭제</a></li>
<li class="chapter" data-level="8.8" data-path="r-list.html"><a href="r-list.html#r-list-function"><i class="fa fa-check"></i><b>8.8</b> 리스트와 함수</a></li>
<li class="chapter" data-level="8.9" data-path="r-list.html"><a href="r-list.html#r-list-string"><i class="fa fa-check"></i><b>8.9</b> 리스트와 문자열</a></li>
<li class="chapter" data-level="8.10" data-path="r-list.html"><a href="r-list.html#r-list-parsing"><i class="fa fa-check"></i><b>8.10</b> 라인 파싱하기(Parsing)</a></li>
<li class="chapter" data-level="8.11" data-path="r-list.html"><a href="r-list.html#r-list-object-value"><i class="fa fa-check"></i><b>8.11</b> 객체와 값(value)</a></li>
<li class="chapter" data-level="8.12" data-path="r-list.html"><a href="r-list.html#r-list-aliasing"><i class="fa fa-check"></i><b>8.12</b> 에일리어싱(Aliasing)</a></li>
<li class="chapter" data-level="8.13" data-path="r-list.html"><a href="r-list.html#r-list-debug"><i class="fa fa-check"></i><b>8.13</b> 디버깅</a></li>
<li class="chapter" data-level="8.14" data-path="r-list.html"><a href="r-list.html#r-list-terminology"><i class="fa fa-check"></i><b>8.14</b> 용어정의</a></li>
<li class="chapter" data-level="8.15" data-path="r-list.html"><a href="r-list.html#r-list-ex"><i class="fa fa-check"></i><b>8.15</b> 연습문제</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="r-db.html"><a href="r-db.html"><i class="fa fa-check"></i><b>9</b> 데이터베이스와 SQL(Structured Query Language) 사용하기</a><ul>
<li class="chapter" data-level="9.1" data-path="r-db.html"><a href="r-db.html#r-db-what-it-is"><i class="fa fa-check"></i><b>9.1</b> 데이터베이스가 뭔가요?</a></li>
<li class="chapter" data-level="9.2" data-path="r-db.html"><a href="r-db.html#r-db-concept"><i class="fa fa-check"></i><b>9.2</b> 데이터베이스 개념</a></li>
<li class="chapter" data-level="9.3" data-path="r-db.html"><a href="r-db.html#r-db-firefox"><i class="fa fa-check"></i><b>9.3</b> 파이어폭스 애드온 SQLite 매니저</a></li>
<li class="chapter" data-level="9.4" data-path="r-db.html"><a href="r-db.html#r-db-create-table"><i class="fa fa-check"></i><b>9.4</b> 데이터베이스 테이블 생성하기</a></li>
<li class="chapter" data-level="9.5" data-path="r-db.html"><a href="r-db.html#r-db-sql"><i class="fa fa-check"></i><b>9.5</b> SQL(Structured Query Language) 요약</a></li>
<li class="chapter" data-level="9.6" data-path="r-db.html"><a href="r-db.html#r-db-modeling"><i class="fa fa-check"></i><b>9.6</b> 데이터 모델링 기초</a></li>
<li class="chapter" data-level="9.7" data-path="r-db.html"><a href="r-db.html#r-db-three-keys"><i class="fa fa-check"></i><b>9.7</b> 세 종류의 키</a></li>
<li class="chapter" data-level="9.8" data-path="r-db.html"><a href="r-db.html#r-db-debugging"><i class="fa fa-check"></i><b>9.8</b> 디버깅</a></li>
<li class="chapter" data-level="9.9" data-path="r-db.html"><a href="r-db.html#r-db-terminology"><i class="fa fa-check"></i><b>9.9</b> 용어정의</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/statkclee/r4inf" target="blank">작업 파일 원본(GitHub)</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">데이터 과학 민주화</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="r-iter" class="section level1">
<h1><span class="header-section-number">Chapter 5</span> 반복(Iteration)</h1>
<div id="r-iter-update" class="section level2">
<h2><span class="header-section-number">5.1</span> 변수 갱신</h2>
<p>대입문의 흔한 패턴은 변수를 갱신하는 대입문이다. 변수의 새로운 값은 이전 값에 의존한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>x +<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>상기 예제는 “현재 값 x에 1을 더해서 x를 새로운 값으로 갱신한다.”</p>
<p>만약 존재하지 않는 변수를 갱신하면, 오류가 발생한다. 왜냐하면 x에 값을 대입하기 전에 R이 오른쪽을 먼저 평가하기 때문이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>x +<span class="dv">1</span>
Error:<span class="st"> </span>object <span class="st">&#39;x&#39;</span> not found</code></pre></div>
<p>변수를 갱신하기 전에 간단한 변수 대입으로 통상 먼저 초기화(initialize)한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">0</span>
x &lt;-<span class="st"> </span>x +<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>1을 더해서 변수를 갱신하는 것을 증가(increment)라고 하고, 1을 빼서 변수를 갱신하는 것을 감소(decrement)라고 한다.</p>
</div>
<div id="r-iter-while" class="section level2">
<h2><span class="header-section-number">5.2</span> while문</h2>
<p>종종 반복적인 작업을 자동화하기 위해서 컴퓨터를 사용한다. 오류 없이 동일하거나 비슷한 작업을 반복하는 일은 컴퓨터가 사람보다 잘한다. 반복이 매우 흔한 일이어서, R에서 반복 작업을 쉽게 하도록 몇가지 언어적 기능을 제공한다.</p>
<p>R에서 반복의 한 형태가 <code>while</code>문이다. 다음은 5 에서부터 거꾸로 세어서 마지막에 “Blastoff(발사)!”를 출력하는 간단한 프로그램이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="dv">5</span>
while(n &gt;<span class="st"> </span><span class="dv">0</span>) {
  <span class="kw">print</span>(n)
  n &lt;-<span class="st"> </span>n -<span class="dv">1</span>
}</code></pre></div>
<pre><code>## [1] 5
## [1] 4
## [1] 3
## [1] 2
## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="st">&quot;Blastoff(발사)!&quot;</span>)</code></pre></div>
<pre><code>## [1] &quot;Blastoff(발사)!&quot;</code></pre>
<p>마치 영어를 읽듯이 <code>while</code>을 읽어 내려갈 수 있다. <code>n</code>이 0 보다 큰 동안에 <code>n</code>의 값을 출력하고 <code>n</code> 값에서 1만큼 뺀다. 0 에 도달했을 때, <code>while</code>문을 빠져나가 Blastoff(발사)!“를 화면에 출력한다.</p>
<p>좀더 형식을 갖춰 정리하면, 다음이 <code>while</code>문에 대한 실행 흐름에 대한 정리다.</p>
<ol style="list-style-type: decimal">
<li>조건을 평가해서 <strong>참(TRUE)</strong> 혹은 <strong>거짓(FALSE)</strong>를 산출한다.</li>
<li>만약 조건이 거짓이면, <code>while</code>문을 빠져나가 다음 문장을 계속 실행한다.</li>
<li>만약 조건이 참이면, 몸통 부문의 문장을 실행하고 다시 처음 1번 단계로 돌아간다.</li>
</ol>
<p>3번째 단계에서 처음으로 다시 돌아가는 반복을 하기 때문에 이런 종류의 흐름을 <strong>루프(loop)</strong>라고 부른다. 매번 루프 몸통 부문을 실행할 때마다, 이것을 <strong>반복(iteration)</strong>이라고 한다. 상기 루프에 대해서 “5번 반복했다”고 말한다. 즉, 루프 몸통 부문이 5번 수행되었다는 의미가 된다.</p>
<p>루프 몸통 부문은 필히 하나 혹은 그 이상의 변수값을 바꾸어서 종국에는 조건식이 <strong>거짓(FALSE)</strong>이 되어 루프가 종료되게 만들어야 한다. 매번 루프가 실행될 때마다 상태를 변경하고 언제 루프가 끝날지 제어하는 변수를 <strong>반복 변수(iteration variable)</strong>라고 한다. 만약 반복 변수가 없다면, 루프는 영원히 반복될 것이고, 결국 <strong>무한 루프(infinite loop)</strong>에 빠질 것이다.</p>
</div>
<div id="r-iter-infinite-loop" class="section level2">
<h2><span class="header-section-number">5.3</span> 무한 루프</h2>
<p>프로그래머에게 무한한 즐거움의 원천은 아마도 “거품내고, 헹구고, 반복” 이렇게 적혀있는 샴프 사용법 문구가 무한루프라는 것을 알아차릴 때일 것이다. 왜냐하면, 얼마나 많이 루프를 실행해야 하는지 말해주는 반복 변수(iteration variable)가 없어서 무한 반복하기 때문입니다.</p>
<p>숫자를 꺼꾸로 세는 (countdown) 예제는 루프가 끝나는 것을 증명할 수 있다. 왜냐하면 <code>n</code>값이 유한하고, <code>n</code>이 매번 루프를 돌 때마다 작아져서 결국 0 에 도달할 것이기 때문이다. 다른 경우 반복 변수가 전혀 없어서 루프가 명백하게 무한 반복한다.</p>
</div>
<div id="--break" class="section level2">
<h2><span class="header-section-number">5.4</span> 무한 반복과 <code id="r-iter-infinite-loop-break">break</code></h2>
<p>가끔 몸통 부문을 절반 진행할 때까지 루프를 종료해야하는 시점인지 확신하지 못한다. 이런 경우 의도적으로 무한 루프를 작성하고 <code>break</code> 문을 사용하여 루프를 빠져 나온다.</p>
<p>다음 루프는 명백하게 무한 루프(infinite loop)가 되는데 이유는 <code>while</code>문 논리 표현식이 단순히 논리 상수 참(TRUE)으로 되어 있기 때문이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="dv">10</span>

while(<span class="ot">TRUE</span>) {
  <span class="kw">print</span>(n)
  n &lt;-<span class="st"> </span>n -<span class="st"> </span><span class="dv">1</span>
}

<span class="kw">print</span>(<span class="st">&#39;Done!&#39;</span>)</code></pre></div>
<p>실수하여 상기 프로그램을 실행한다면, 폭주하는 R 프로세스를 어떻게 멈추는지 빨리 배우거나, 컴퓨터의 전원 버튼이 어디에 있는지 찾아야 할 것이다. 표현식 상수 값이 참(TRUE)이라는 사실로 루프 상단 논리 연산식이 항상 참 값이여서 프로그램이 영원히 혹은 배터리가 모두 소진될 때까지 실행된다.</p>
<p>이것이 역기능 무한 루프라는 것은 사실이지만, 유용한 루프를 작성하기 위해는 이 패턴을 여전히 이용할 것이다. 이를 위해서 루프 몸통 부문에 <code>break</code>문을 사용하여 루프를 빠져나가는 조건에 도달했을 때, 루프를 명시적으로 빠져나갈 수 있도록 주의깊게 코드를 추가해야 한다.</p>
<p>예를 들어, 사용자가 done을 입력하기 전까지 사용자로부터 입력값을 받는다고 가정해서 프로그램 코드를 다음과 같이 작성한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">while(<span class="ot">TRUE</span>) {
  line &lt;-<span class="st"> </span><span class="kw">readline</span>(<span class="dt">prompt =</span> <span class="st">&#39;&gt; &#39;</span>)
  if(line ==<span class="st"> &#39;done&#39;</span>) {
    break
  }
  <span class="kw">print</span>(line)
}</code></pre></div>
<p>루프 조건이 항상 참(TRUE)이여서 <code>break</code>문이 호출될 때까지 루프는 반복적으로 실행된다.</p>
<p>매번 프로그램이 꺾쇠 괄호로 사용자에게 명령문을 받을 준비를 한다. 사용자가 done을 타이핑하면, <code>break</code>문이 실행되어 루프를 빠져나온다. 그렇지 않은 경우 프로그램은 사용자가 무엇을 입력하든 메아리처럼 입력한 것을 그대로 출력하고 다시 루프 처음으로 되돌아 간다. 다음 예제로 실행한 결과가 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>hello there
hello there
&gt;<span class="st"> </span>finished
finished
&gt;<span class="st"> </span>done
&gt;<span class="st"> </span>done
Error:<span class="st"> </span>object <span class="st">&#39;done&#39;</span> not found</code></pre></div>
<p><code>while</code> 루프를 이와 같은 방식으로 작성하는 것이 흔한데 프로그램 상단에서 뿐만 아니라 루프 어디에서나 조건을 확인할 수 있고 피동적으로 “이벤트가 발생할 때까지 계속 실행” 대신에, 적극적으로 “이벤트가 생겼을 때 중지”로 멈춤 조건을 표현할 수 있다.</p>
</div>
<div id="r-iter-stop" class="section level2">
<h2><span class="header-section-number">5.5</span> <code>next</code>로 반복 종료</h2>
<p>때때로 루프를 반복하는 중간에서 현재 반복을 끝내고, 다음 반복으로 즉시 점프하여 이동하고 싶을 때가 있다. 현재 반복 루프 몸통 부분 전체를 끝내지 않고 다음 반복으로 건너뛰기 위해서 <code>next</code>문을 사용한다.</p>
<p>사용자가 “done”을 입력할 때까지 입력값을 그대로 복사하여 출력하는 루프 예제가 있다. 하지만 R 주석문처럼 해쉬(#)로 시작하는 줄은 출력하지 않느다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">while(<span class="ot">TRUE</span>) {
  line &lt;-<span class="st"> </span><span class="kw">readline</span>(<span class="dt">prompt =</span> <span class="st">&#39;&gt; &#39;</span>)
  if(<span class="kw">substr</span>(line,<span class="dv">1</span>,<span class="dv">1</span>) ==<span class="st"> &quot;#&quot;</span>) {
    next
  }
  if(line ==<span class="st"> &#39;done&#39;</span>) {
    break
  }
  <span class="kw">print</span>(line)
}</code></pre></div>
<p><code>next</code>문이 추가된 새로운 프로그램을 샘플로 실행했다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">&gt;<span class="st"> </span>hello there
[<span class="dv">1</span>] hello there
&gt;<span class="st"> </span><span class="co"># don&#39;t print this</span>
<span class="er">&gt;</span><span class="st"> </span>print this!
[<span class="dv">2</span>] print this!
<span class="er">&gt;</span><span class="st"> </span>done</code></pre></div>
<p>해쉬 기호(#)로 시작하는 줄을 제외하고 모든 줄을 출력한다. 왜냐하면, <code>next</code>문이 실행될 때,현재 반복을 종료하고 <code>while</code>문 처음으로 돌아가서 다음 반복을 실행하게 되어서 <code>print</code>문을 건너뛴다.</p>
</div>
<div id="r-iter-for" class="section level2">
<h2><span class="header-section-number">5.6</span> for문을 사용한 명확한 루프</h2>
<p>때때로, 단어 리스트나, 파일의 줄, 숫자 리스트 같은 사물의 집합에 대해 루프를 반복할 때가 있다. 루프를 반복할 사물 리스트가 있을 때, <code>for</code>문을 사용해서 <strong>확정 루프(definite loop)</strong>를 구성한다.</p>
<p><code>while</code>문을 <strong>불확정 루프(indefinite loop)</strong>라고 하는데, 왜냐하면 어떤 조건이 거짓(FALSE)가 될 때까지 루프가 단순히 계혹해서 돌기 때문이다. 하지만, <code>for</code>루프는 확정된 항목의 집합에 대해서 루프가 돌게 되어서 집합에 있는 항목만큼만 실행이 된다.</p>
<p><code>for</code>문이 있고, 루프 몸통 부문으로 구성된다는 점에서 <code>for</code>루프 구문은 <code>while</code>루프 구문과 비슷하다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">friends &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;Joseph&#39;</span>, <span class="st">&#39;Glenn&#39;</span>, <span class="st">&#39;Sally&#39;</span>)

for(friend in friends) {
  <span class="kw">cat</span>(<span class="st">&#39;Happy New Year:&#39;</span>, friend, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
}</code></pre></div>
<p>R 용어로, 변수 <code>friends</code>는 3개의 문자열을 가지는 벡터이며, <code>for</code> 루프는 벡터내 원소를 하나씩 하나씩 찾아서 벡터에 있는 3개 문자열 각각에 대해 출력을 실행하여 다음 결과를 얻게 된다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Happy New Year:<span class="st"> </span>Joseph 
Happy New Year:<span class="st"> </span>Glenn 
Happy New Year:<span class="st"> </span>Sally </code></pre></div>
<p><code>for</code> 루프를 영어로 번역하는 것이 <code>while</code>문을 번역하는 것과 같이 직접적이지는 않다. 하지만, 만약 <code>friends</code>를 집합(set)으로 생각한다면 다음과 같다. <code>friends</code>라고 명명된 집합에서 <code>friend</code> 각각에 대해서 한번씩 <code>for</code> 루프 몸통 부문에 있는 문장을 실행하라.</p>
<p><code>for</code> 루프를 살펴보면, <code>for</code>와 <code>in</code>은 R 예약어이고 <code>friend</code>와 <code>friends</code>는 변수이다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">for(friend in friends) {
  <span class="kw">cat</span>(<span class="st">&#39;Happy New Year:&#39;</span>, friend, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
}</code></pre></div>
<p>특히, <code>friend</code>는 <code>for</code> 루프의 <strong>반복 변수(iteration variable)</strong>다. 변수 <code>friend</code>는 루프가 매번 반복할 때마다 변하고, 언제 <code>for</code> 루프가 완료되는지 제어한다. 반복 변수는 <code>friends</code> 변수에 저장된 3개 문자열을 순차적으로 훑고 간다.</p>
</div>
<div id="r-iter-for-pattern" class="section level2">
<h2><span class="header-section-number">5.7</span> 루프 패턴</h2>
<p>종종 <code>for</code>문과 <code>while</code>문을 사용하여, 벡터나 리스트 항목, 파일 콘텐츠를 훑어 자료에 있는 가장 큰 값이나 작은 값 같은 것을 찾는다.</p>
<p><code>for</code>나 <code>while</code> 루프는 일반적으로 다음과 같이 구축된다.</p>
<ol style="list-style-type: decimal">
<li>루프가 시작하기 전에 하나 혹은 그 이상의 변수를 초기화</li>
<li>루프 몸통부분에 각 항목에 대해 연산을 수행하고, 루프 몸통 부분의 변수 상태를 변경</li>
<li>루프가 완료되면 결과 변수의 상태 확인</li>
</ol>
<p>루프 패턴의 개념과 작성을 시연하기 위해서 숫자 벡터를 사용한다.</p>
<div id="r-iter-for-pattern-sum" class="section level3">
<h3><span class="header-section-number">5.7.1</span> 계수(counting)와 합산 루프</h3>
<p>예를 들어, 벡터의 항목을 세기 위해서 다음과 같이 <code>for</code> 루프를 작성한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">count &lt;-<span class="st"> </span><span class="dv">0</span>
for(itervar in <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">41</span>, <span class="dv">12</span>, <span class="dv">9</span>, <span class="dv">74</span>, <span class="dv">15</span>)){
  count &lt;-<span class="st"> </span>count +<span class="st"> </span><span class="dv">1</span>
}

<span class="kw">cat</span>(<span class="st">&#39;Count: &#39;</span>, count)</code></pre></div>
<pre><code>## Count:  6</code></pre>
<p>루프가 시작하기 전에 변수 <code>count</code>를 0 으로 설정하고, 숫자 목록을 훑어 갈 <code>for</code> 루프를 작성한다. 반복(iteration) 변수는 <code>itervar</code>라고 하고, 루프에서 <code>itervar</code>을 사용되지 않지만, <code>itervar</code>는 루프를 제어하고 루프 몸통 부문 리스트의 각 값에 대해서 한번만 실행되게 한다.</p>
<p>루프 몸통 부문에 리스트의 각 값에 대해서 변수 <code>count</code> 값에 1을 더한다. 루프가 실행될 때, <code>count</code> 값은 “지금까지” 살펴본 값의 횟수가 된다.</p>
<p>루프가 종료되면, <code>count</code> 값은 총 항목 숫자가 된다. 총 숫자는 루프 맨마지막에 얻어진다. 루프를 구성해서, 루프가 끝났을 때 기대했던 바를 얻었다.</p>
<p>숫자 집합의 갯수를 세는 또 다른 비슷한 루프는 다음과 같다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">total &lt;-<span class="st"> </span><span class="dv">0</span>
for(itervar in <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">41</span>, <span class="dv">12</span>, <span class="dv">9</span>, <span class="dv">74</span>, <span class="dv">15</span>)){
  total &lt;-<span class="st"> </span>total +<span class="st"> </span>itervar
}

<span class="kw">cat</span>(<span class="st">&#39;Total: &#39;</span>, total)</code></pre></div>
<pre><code>## Total:  154</code></pre>
<p>상기 루프에서, 반복 변수(iteration variable)가 사용되었다. 앞선 루프에서처럼 변수 <code>count</code>에 1을 단순히 더하는 대신에, 각 루프가 반복을 수행하는 동안 실제 숫자 (3, 41, 12, 등)를 작업중인 합계에 덧셈을 했다. 변수 <code>total</code>을 생각해보면, total은 “지금까지 값의 총계다.” 루프가 시작하기 전에 <code>total</code>은 어떤 값도 살펴본 적이 없어서 0 이다. 루프가 도는 중에는 <code>total</code>은 작업중인 총계가 된다. 루프의 마지막 단계에서 <code>total</code>은 리스트에 있는 모든 값의 총계가 된다.</p>
<p>루프가 실행됨에 따라, <code>total</code>은 각 요소의 합계로 누적된다. 이 방식으로 사용되는 변수를 <strong>누산기(accumulator)</strong>라고 한다.</p>
<p>계수(counting) 루프나 합산 루프는 특히 실무에서 유용하지는 않다. 왜냐하면 리스트에서 항목의 개수와 총계를 계산하는 <code>length()</code>과 <code>sum()</code>가 각각 내장 함수로 있기 때문이다.</p>
</div>
<div id="r-iter-for-min-max" class="section level3">
<h3><span class="header-section-number">5.7.2</span> 최대값과 최소값 루프</h3>
<p>리스트, 벡터나 열(sequence)에서 가장 큰 값을 찾기 위해서, 다음과 같이 루프를 작성한다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">largest &lt;-<span class="st"> </span><span class="ot">NA</span>

<span class="kw">cat</span>(<span class="st">&#39;Before:&#39;</span>, largest, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)

for(itervar in <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">41</span>, <span class="dv">12</span>, <span class="dv">9</span>, <span class="dv">74</span>, <span class="dv">15</span>)){
  if(<span class="kw">is.na</span>(largest) ||<span class="st"> </span>itervar &gt;<span class="st"> </span>largest){
    largest &lt;-<span class="st"> </span>itervar
    <span class="kw">cat</span>(<span class="st">&#39;Loop:&#39;</span>, itervar, largest, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&#39;Largest:&#39;</span>, largest, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
}</code></pre></div>
<p>프로그램을 실행하면, 출력은 다음과 같다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Loop:<span class="st"> </span><span class="dv">3</span> <span class="dv">3</span> 
Largest:<span class="st"> </span><span class="dv">3</span> 
Loop:<span class="st"> </span><span class="dv">41</span> <span class="dv">41</span> 
Largest:<span class="st"> </span><span class="dv">41</span> 
Loop:<span class="st"> </span><span class="dv">74</span> <span class="dv">74</span> 
Largest:<span class="st"> </span><span class="dv">74</span> </code></pre></div>
<p>변수 <code>largest</code>는 “지금까지 본 가장 큰 수”로 생각할 수 있다. 루프 시작 전에 <code>largest</code> 값은 상수 <code>NA</code>이다. <code>NA</code>은 “빈(empty)” 변수를 표기하기 위해서 변수에 저장하는 특별한 상수 값이다.</p>
<p>루프 시작 전에 지금까지 본 가장 큰 수는 <code>NA</code>이다. 왜냐하면 아직 어떤 값도 보지 않았기 때문이다. 루프가 실행되는 동안에, <code>largest</code> 값이 <code>NA</code> 이면, 첫 번째 본 값이 지금까지 본 가장 큰 값이 된다. 첫번째 반복에서 <code>itervar</code>는 3 이 되는데 <code>largest</code> 값이 <code>NA</code>이여서 즉시, <code>largest</code>값을 3 으로 갱신한다.</p>
<p>첫번째 반복 후에 <code>largest</code>는 더 이상 <code>NA</code>가 아니다. <code>itervar &gt; largest</code>인지를 확인하는 복합 논리 표현식의 두 번째 부분은 “지금까지 본” 값 보다 더 큰 값을 찾게 될 때 자동으로 동작한다. “심지어 더 큰” 값을 찾게 되면 변수 <code>largest</code>에 새로운 값으로 대체한다. <code>largest</code>가 3에서 41, 41에서 74로 변경되어 출력되어 나가는 것을 확인할 수 있다.</p>
<p>루프의 끝에서 모든 값을 훑어서 변수 <code>largest</code>는 리스트의 가장 큰 값을 담고 있다.</p>
<p>최소값을 계산하기 위해서는 코드가 매우 유사하지만 작은 변화가 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">smallest &lt;-<span class="st"> </span><span class="ot">NA</span>

<span class="kw">cat</span>(<span class="st">&#39;Before:&#39;</span>, smallest, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)

for(itervar in <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">41</span>, <span class="dv">12</span>, <span class="dv">9</span>, <span class="dv">74</span>, <span class="dv">15</span>)){
  if(<span class="kw">is.na</span>(smallest) ||<span class="st"> </span>itervar &lt;<span class="st"> </span>smallest){
    smallest &lt;-<span class="st"> </span>itervar
    <span class="kw">cat</span>(<span class="st">&#39;Loop:&#39;</span>, itervar, smallest, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&#39;Largest:&#39;</span>, smallest, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
  }
}</code></pre></div>
<p>변수 <code>smallest</code>는 루프 실행 전에, 중에, 완료 후에 “지금까지 본 가장 작은” 값이 된다. 루프 실행이 완료되면, <code>smallest</code>는 벡터의 최소값을 담게 된다.</p>
<p>계수(counting)과 합산에서와 마찬가지로 R 내장함수 <code>max()</code>와 <code>min()</code>은 이런 루프문 작성을 불필요하게 만든다.</p>
<p>다음은 R 내장 min() 함수의 간략 버전이다. <code>getAnywhere(min)</code>, <code>.Primitive(&quot;min&quot;)</code>을 입력해도 원소스코드를 볼 수는 없다. <code>names(methods:::.BasicFunsList)</code> 명령어를 통해 <code>.Primitive()</code> 함수를 파악할 수 있다.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">min &lt;-<span class="st"> </span>function(values) {
  smallest &lt;-<span class="st"> </span><span class="ot">NA</span>
  for(value in values){
    if(<span class="kw">is.na</span>(smallest) ||<span class="st"> </span>value &lt;<span class="st"> </span>smallest){
      smallest &lt;-<span class="st"> </span>value
  <span class="kw">return</span>(smallest)      
  }
}</code></pre></div>
<p>가장 적은 코드로 작성한 함수 버전은 R에 이미 내장된 <code>min</code> 함수와 동등하게 만들기 위해서 모든 <code>print</code>문을 삭제했다.</p>
</div>
</div>
<div id="r-iter-debug" class="section level2">
<h2><span class="header-section-number">5.8</span> 디버깅</h2>
<p>좀더 큰 프로그램을 작성할 때, 좀더 많은 시간을 디버깅에 보내는 자신을 발견할 것이다. 좀더 많은 코드는 버그가 숨을 수 있는 좀더 많은 장소와 오류가 발생할 기회가 있다는 것을 의미한다.</p>
<p>디버깅 시간을 줄이는 한 방법은 <strong>“이분법에 따라 디버깅(debugging by bisection)”</strong> 하는 것이다. 예를 들어, 프로그램에 100 줄이 있고 한번에 하나씩 확인한다면, 100 번 단계가 필요하다.</p>
<p>대신에 문제를 반으로 나눈다. 프로그램 정확히 중간이나, 중간부분에서 점검한다. <code>print</code>문이나, 검증 효과를 갖는 상응하는 대용물을 넣고 프로그램을 실행한다.</p>
<p>중간지점 점검 결과 잘못 되었다면 문제는 양분한 프로그램 앞부분에 틀림없이 있다. 만약 정확하다면, 문제는 프로그램 뒷부분에 있다.</p>
<p>이와 같은 방식으로 점검하게 되면, 검토 해야하는 코드의 줄수를 절반으로 계속 줄일 수 있다. 단계가 100 번 걸리는 것에 비해 6번 단계 후에 이론적으로 1 혹은 2 줄로 문제 코드의 범위를 좁힐 수 있다.</p>
<p>실무에서, “프로그램의 중간”이 무엇인지는 명확하지 않고, 확인하는 것도 가능하지 않다. 프로그램 코드 라인을 세서 정확히 가운데를 찾는 것은 의미가 없다. 대신에 프로그램 오류가 생길 수 있는 곳과 오류를 확인하기 쉬운 장소를 생각하세요. 점검 지점 앞뒤로 버그가 있을 곳과 동일하게 생각하는 곳을 중간지점으로 고르세요.</p>
</div>
<div id="r-iter-terminology" class="section level2">
<h2><span class="header-section-number">5.9</span> 용어정의</h2>
<ul>
<li><strong>누산기(accumulator)</strong>: 더하거나 결과를 누적하기 위해 루프에서 사용되는 변수</li>
<li><strong>계수(counter)</strong>: 루프에서 어떤 것이 일어나는 횟수를 기록하는데 사용되는 변수. 카운터를 0 으로 초기화하고, 어떤 것의 “횟수”를 셀 때 카운터를 증가시킨다.</li>
<li><strong>감소(decrement)</strong>: 변수 값을 감소하여 갱신</li>
<li><strong>초기화(initialize)</strong>: 갱신될 변수의 값을 초기 값으로 대입</li>
<li><strong>증가(increment)</strong>: 변수 값을 증가시켜 갱신 (통상 1씩)</li>
<li><strong>무한 루프(infinite loop)</strong>: 종료 조건이 결코 만족되지 않거나 종료 조건이 없는 루프</li>
<li><strong>반복(iteration)</strong>: 재귀함수 호출이나 루프를 사용하여 명령문을 반복 실행</li>
</ul>
</div>
<div id="r-iter-ex" class="section level2">
<h2><span class="header-section-number">5.10</span> 연습문제</h2>
<ol style="list-style-type: decimal">
<li>사용자가 “done”을 입력할 때까지 반복적으로 숫자를 읽는 프로그램을 작성하세요. “done”이 입력되면, 총계, 갯수, 평균을 출력하세요. 만약 숫자가 아닌 다른 것을 입력하게되면, <code>tryCatch</code>를 사용하여 사용자 실수를 탐지해서 오류 메시지를 출력하고 다음 숫자로 건너 뛰게 하세요.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Enter a number:<span class="st"> </span><span class="dv">4</span>
Enter a number:<span class="st"> </span><span class="dv">5</span>
Enter a number:<span class="st"> </span>bad data
Invalid input
Enter a number:<span class="st"> </span><span class="dv">7</span>
Enter a number:<span class="st"> </span>done
<span class="dv">16</span> <span class="dv">3</span> <span class="fl">5.33333333333</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>위에서처럼 숫자 목록을 사용자로부터 입력받는 프로그램을 작성하세요. 평균값 대신에 숫자 목록 최대값과 최소값을 출력하세요.</li>
</ol>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="r-func.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="r-string.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/statkclee/r4inf/edit/master/05-loop.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
